1.  Implement
	a.  Pragma
	b.  Error
	c.  Warning
	d.  Line
	e.  FuncCall

2.  AST Transformations.  Possible formats:

  FunctionDefinition( name=declarator.identifier, parameters=declarator.find(ParameterList), return=)

3.  AST Constraints.  Possible formats:

  FunctionDefinition.body == CompoundExpression
  "A function body must be a compound statement"

4.  function_definition and declaration?

both start with a list of declaration_specifiers

function := list(declaration_specifier) + declarator + declaration_list_opt + compound_statement

<decl_spec>inline</decl_spec>
<declarator>int func(a,b,c)</declarator>
<decl_list>
int a;
int * b;
char c;
<decl_list>
<compound_statement>
{
  return a;
}
</compound_statement>

declaration := list(declaration_specifier) + init_declarator_list_opt + 'semi'

extern extern int b = 3;
static struct b {
  int a;
  int b;
};
int func() {}
int foo(a,b)
  char a;
  char b;
{}

int (*ptr)(short a, short b, short c);

When you see a lbrace, enqueue tokens until corresponding rbrace.  If next token is a semi-colon, it's a declaration.  If not, it's a function definition



C Helper Tokens
---------------

comma_va_args - a comma that comes before an elipsis
trailing_comma - comma before an rbrace
declarator_hint - 
function_definition_hint
defined_separator
typedef_identifier

Typedefs, how do they work?
---------------------------

A typedef_identifier looks like it's the last identifier before a semi-colon at brace level 0;
  1) Read ahead and cache everything until a semi-colon at brace level 0.
  2) Loop through stack backwards (from the semi-colon to the current token)
    if token == identifier:
      token = typedef_identifier

examples:

typedef struct a {
  int x;
  char y;
} NAME;

typedef int * int_ptr;

typedef int (*pt2Function)(float, char, char);
